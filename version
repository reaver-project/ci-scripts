#!/usr/bin/env python

import argparse
from os import path, getcwd
import json
import re
import pygit2


class Version:
    tag = None
    _exceptions = []

    def __init__(self, tag, version_description):
        self.tag = tag
        if 'exceptions' in version_description:
            self._exceptions = version_description['exceptions']

    def add_exceptions(self, exceptions):
        self._exceptions += exceptions

    def remove_exception(self, exception):
        self._exceptions.remove(exception)

    def exceptions(self):
        return self._exceptions

    def json(self):
        return {
            'exceptions': self._exceptions
        }


class Package:
    name = None
    bases = []

    _versions = {}

    def __init__(self, package_name):
        self.name = package_name
        filename = path.join('versions', package_name + '.json')

        with open(filename) as file:
            package = json.load(file)

        if 'bases' in package:
            self.bases = package['bases']

        if 'versions' in package:
            self._versions = { x: Version(x, value) for x, value in package['versions'].iteritems() }

    def __getitem__(self, index):
        return self._versions[index]

    def save(self):
        filename = path.join('versions', self.name + '.json')

        package = {
            "package": self.name,
            "bases": self.bases,
            "versions": { tag: version.json() for tag, version in self._versions.iteritems() }
        }

        with open(filename, 'w') as file:
            json.dump(package, file, indent = 4, sort_keys = True, separators = (',', ': '))

    def versions(self):
        return self._versions

    def add_version(self, tag, exceptions = []):
        self._versions[tag] = Version(tag, { 'exceptions': exceptions })

    def allowed_base(self, version, base):
        patterns = [ '-'.join([ k + '-' + v for k, v in exception.iteritems() ]) for exception in self._versions[version].exceptions() ]
        if not len(patterns):
            return True

        pattern = re.compile('(' + ')|('.join(patterns) + ')')
        return pattern.match(base) == None

    def combined_versions(self):
        if len(self.bases):
            all_bases = [ version for base in self.bases for version in limited_package(base).combined_versions() ]
            return [ base + '/' + self.name + ':' + v for v in self._versions for base in all_bases if self.allowed_base(v, base) ]

        return [ self.name + ':' + v for v in self._versions ]


def limited_package(full_base):
    if full_base.find('/') == -1:
        return Package(full_base)

    metabase, base = full_base.rsplit('/', 1)
    package = Package(base)
    package.bases = [ metabase ]
    return package


def commit_changes(package):
    repo = pygit2.Repository(pygit2.discover_repository(getcwd()))

    repo.index.add(path.join('versions', package + '.json'))
    repo.index.write()
    tree = repo.index.write_tree()

    config = pygit2.Config.get_global_config()
    name = list(config.get_multivar('user.name'))[0].encode('utf-8')
    email = list(config.get_multivar('user.email'))[0].encode('utf-8')
    author = pygit2.Signature(name, email)

    repo.create_commit(
        repo.head.name,
        author,
        author,
        '[Reaver Project CI Scripts/version] Update package: ' + package + '.',
        tree,
        [ repo.head.peel().oid ]
    )

parser = argparse.ArgumentParser(description = 'Reaver Project CI scripts: version')
parser.add_argument('-c', '--commit', action = 'store_true', help = 'Make a git commit after adding the version.')
subparsers = parser.add_subparsers(dest = 'command')

add_parser = subparsers.add_parser('add', help = 'Add a version to a package.')
add_parser.add_argument('package', nargs = 1)
add_parser.add_argument('version', nargs = 1)
add_parser.add_argument('-e', '--exception', action = 'append', help = 'Add an exception to specified version. The format is as follows: package1:version1/package2:version2. ' +
    'The above specifies that this version is not to be built in combination with package1 in version1 and package2 in version2.\n')

get_parser = subparsers.add_parser('get', help = 'Get all allowed combinations of package versions and its bases.')
get_parser.add_argument('package', nargs = 1)

args = parser.parse_args()

if args.command == 'add':
    package = Package(args.package[0])
    version = args.version[0]

    exceptions = []
    if args.exception is not None:
        exceptions = [ dict([ x.split(':') for x in exception.split('/') ]) for exception in args.exception ]

    if version not in package.versions().keys():
        package.add_version(version, exceptions)
    else:
        package[version].add_exceptions(exceptions)

    package.save()

    if args.commit:
        commit_changes(package.name)

if args.command == 'get':
    package = Package(args.package[0])
    for version in package.combined_versions():
        print version

